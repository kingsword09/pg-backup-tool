# .github/workflows/build.yml
name: Reusable Build Workflow

# This is a reusable workflow that builds, tests, and packages the PG tools
# for a single platform. It is called by 'ci.yml' and 'release.yml'.

on:
  workflow_call:
    inputs:
      id:
        type: string
        required: true
      target:
        type: string
        required: true
      os:
        type: string
        required: true
      platform:
        type: string
      release:
        description: If this is a release build, set to true.
        type: boolean
        default: false

jobs:
  build:
    name: Build for ${{ inputs.id }}
    runs-on: ${{ inputs.os }}
    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v4

      - name: Setup Environment Variables
        run: |
          #
          # Set PostgreSQL Version
          #
          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            # e.g., "v16.3.2" -> "16.3.2"
            raw_tag="${{ github.ref_name }}"
            full_version="${raw_tag#v}"
          else
            # Default version for CI/manual runs. This must be a valid, released version.
            full_version="17.5"
          fi

          #
          # Determine Download and Archive Versions
          #
          # The PostgreSQL source tarball's name and its URL path *always* use the major.minor version.
          # e.g., for tag v16.3.2, the URL is .../v16.3/postgresql-16.3.tar.gz
          # The unpacked directory will be postgresql-16.3.
          #
          download_version=$(echo "$full_version" | awk -F. '{print $1"."$2}')
          
          # The final release asset should use the full, unique tag version for its name.
          archive_name="pg-tools-v$full_version-${{ inputs.id }}"

          root_directory="$(pwd)"
          install_directory="$root_directory/$archive_name"

          # PG_VERSION is used for the tarball filename and the name of the unpacked source directory (e.g., 16.3)
          echo "PG_VERSION=$download_version" | tee -a $GITHUB_ENV
          # PG_MAJOR_VERSION is for the URL path, which is the same as PG_VERSION in this corrected logic (e.g., 16.3)
          echo "PG_MAJOR_VERSION=$download_version" | tee -a $GITHUB_ENV
          # PG_FULL_VERSION is used for verification in the test script (e.g., 16.3.2)
          echo "PG_FULL_VERSION=$full_version" | tee -a $GITHUB_ENV
          
          echo "ARCHIVE_NAME=$archive_name" | tee -a $GITHUB_ENV
          echo "INSTALL_DIR=$install_directory" | tee -a $GITHUB_ENV
          echo "ROOT_DIR=$root_directory" | tee -a $GITHUB_ENV

      # =================================================================
      # Linux Build (using Docker)
      # =================================================================
      - name: Setup Docker Build (Linux)
        if: runner.os == 'Linux'
        run: |
          docker run --privileged --rm tonistiigi/binfmt --install all
          if [[ "${{ inputs.id }}" == *musl* ]]; then
            echo "DOCKERFILE=dockerfiles/Dockerfile.linux-musl" >> $GITHUB_ENV
          else
            echo "DOCKERFILE=dockerfiles/Dockerfile.linux-gnu" >> $GITHUB_ENV
          fi

      - name: Build with Docker (Linux)
        if: runner.os == 'Linux'
        run: |
          docker buildx build \
            --build-arg "POSTGRESQL_VERSION=${PG_VERSION}" \
            --build-arg "PG_MAJOR_VERSION=${PG_MAJOR_VERSION}" \
            --platform "${{ inputs.platform }}" \
            --tag pg-tools-build:latest \
            -f "${{ env.DOCKERFILE }}" .
          
          container_id=$(docker create --platform "${{ inputs.platform }}" pg-tools-build:latest)
          docker cp "${container_id}:/opt/postgresql" "${INSTALL_DIR}"
          docker rm -v "${container_id}"

      # =================================================================
      # macOS Build (from source)
      # =================================================================
      - name: Install Dependencies (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install openssl zlib

      - name: Download and Extract Source (macOS)
        if: runner.os == 'macOS'
        run: |
          # URL uses major version for the path and full version for the filename.
          wget "https://ftp.postgresql.org/pub/source/v${PG_MAJOR_VERSION}/postgresql-${PG_VERSION}.tar.gz"
          tar -xzf "postgresql-${PG_VERSION}.tar.gz"

      - name: Build from Source (macOS)
        if: runner.os == 'macOS'
        working-directory: postgresql-${{ env.PG_VERSION }}
        env:
          # The most reliable method to help `configure` find Homebrew libraries
          # is to set the PKG_CONFIG_PATH. LDFLAGS and CPPFLAGS are included as a fallback.
          PKG_CONFIG_PATH: "$(brew --prefix openssl)/lib/pkgconfig"
          LDFLAGS: "-L$(brew --prefix openssl)/lib"
          CPPFLAGS: "-I$(brew --prefix openssl)/include"
        run: |
          # The LDFLAGS and CPPFLAGS env vars will be used automatically by ./configure.
          ./configure \
            --prefix=${INSTALL_DIR} \
            --without-readline \
            --with-openssl \
            --with-zlib \
            --without-icu
          make -C src/interfaces/libpq all install
          make -C src/bin/pg_dump all install
          make -C src/bin/pg_restore all install

      - name: Update library paths (macOS)
        if: runner.os == 'macOS'
        run: |
          # This step makes the compiled binaries portable by changing the hardcoded
          # absolute path to libpq.5.dylib to a relative path.
          echo "Fixing library paths in pg_dump and pg_restore..."
          for bin in pg_dump pg_restore; do
            install_name_tool -change "${INSTALL_DIR}/lib/libpq.5.dylib" \
              "@executable_path/../lib/libpq.5.dylib" \
              "${INSTALL_DIR}/bin/$bin"
          done

      # =================================================================
      # Windows Build (using pre-compiled binaries)
      # =================================================================
      - name: Download and Extract Binaries (Windows)
        if: runner.os == 'Windows'
        run: |
          # EnterpriseDB download URLs use the major.minor version string.
          # Use curl's flags to follow redirects (-L), fail on server errors (-f), and run silently (-s).
          curl -Lfs -o postgresql.zip "https://get.enterprisedb.com/postgresql/postgresql-${PG_MAJOR_VERSION}-1-windows-x64-binaries.zip"
          unzip -q postgresql.zip
          mkdir -p "${INSTALL_DIR}"
          mv pgsql/bin "${INSTALL_DIR}/"
          mv pgsql/lib "${INSTALL_DIR}/"
          rm -rf pgsql

      # =================================================================
      # Packaging and Testing
      # =================================================================
      - name: Package Artifacts
        id: package
        run: |
          cp "README.md" "${INSTALL_DIR}/"
          if [[ "${{ runner.os }}" == "Windows" ]]; then
            7z a "${ARCHIVE_NAME}.zip" "${ARCHIVE_NAME}"
            echo "ASSET_PATH=${ARCHIVE_NAME}.zip" >> $GITHUB_OUTPUT
          else
            tar -czf "${ARCHIVE_NAME}.tar.gz" -C "${ROOT_DIR}" "${ARCHIVE_NAME}"
            echo "ASSET_PATH=${ARCHIVE_NAME}.tar.gz" >> $GITHUB_OUTPUT
          fi

      - name: Test Binaries
        run: |
          # Change directory within the script for Windows compatibility.
          cd "${INSTALL_DIR}"
          cp "${ROOT_DIR}/scripts/test.sh" .
          chmod +x test.sh
          # Test against the full version string, which is what `pg_dump --version` will output.
          ./test.sh "${PG_FULL_VERSION}"

      # Upload the final archive as an artifact for both CI and Release runs.
      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARCHIVE_NAME }}
          path: ${{ steps.package.outputs.ASSET_PATH }}

      # =================================================================
      # Release to GitHub (only if triggered by release workflow)
      # =================================================================
      - name: Upload to GitHub Release
        if: inputs.release == true
        uses: softprops/action-gh-release@v2
        with:
          files: ${{ steps.package.outputs.ASSET_PATH }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
